/*
Copyright 2022.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

//
// Generated by:
//
// operator-sdk create webhook --group telemetry --version v1beta1 --kind Telemetry --programmatic-validation --defaulting
//

package v1beta1

import (
	"fmt"

	topologyv1 "github.com/openstack-k8s-operators/infra-operator/apis/topology/v1beta1"
	apierrors "k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/util/validation/field"
	logf "sigs.k8s.io/controller-runtime/pkg/log"
	"sigs.k8s.io/controller-runtime/pkg/webhook"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// TelemetryDefaults -
type TelemetryDefaults struct {
	CentralContainerImageURL        string
	ComputeContainerImageURL        string
	NotificationContainerImageURL   string
	SgCoreContainerImageURL         string
	ProxyContainerImageURL          string
	IpmiContainerImageURL           string
	KsmContainerImageURL            string
	MysqldExporterContainerImageURL string
	AodhAPIContainerImageURL        string
	AodhEvaluatorContainerImageURL  string
	AodhNotifierContainerImageURL   string
	AodhListenerContainerImageURL   string
	CloudKittyAPIContainerImageURL  string
	CloudKittyProcContainerImageURL string
}

var telemetryDefaults TelemetryDefaults

// log is for logging in this package.
var telemetrylog = logf.Log.WithName("telemetry-resource")

// SetupTelemetryDefaults - initialize Telemetry spec defaults for use with either internal or external webhooks
func SetupTelemetryDefaults(defaults TelemetryDefaults) {
	telemetryDefaults = defaults
	telemetrylog.Info("Telemetry defaults initialized", "defaults", defaults)
}

var _ webhook.Defaulter = &Telemetry{}

// Default implements webhook.Defaulter so a webhook will be registered for the type
func (r *Telemetry) Default() {
	telemetrylog.Info("default", "name", r.Name)

	r.Spec.Default()
}

// Default - set defaults for this Telemetry spec
func (spec *TelemetrySpec) Default() {
	if spec.Ceilometer.CeilometerSpec.CentralImage == "" {
		spec.Ceilometer.CeilometerSpec.CentralImage = telemetryDefaults.CentralContainerImageURL
	}
	if spec.Ceilometer.CeilometerSpec.ComputeImage == "" {
		spec.Ceilometer.CeilometerSpec.ComputeImage = telemetryDefaults.ComputeContainerImageURL
	}
	if spec.Ceilometer.CeilometerSpec.IpmiImage == "" {
		spec.Ceilometer.CeilometerSpec.IpmiImage = telemetryDefaults.IpmiContainerImageURL
	}
	if spec.Ceilometer.CeilometerSpec.NotificationImage == "" {
		spec.Ceilometer.CeilometerSpec.NotificationImage = telemetryDefaults.NotificationContainerImageURL
	}
	if spec.Ceilometer.CeilometerSpec.SgCoreImage == "" {
		spec.Ceilometer.CeilometerSpec.SgCoreImage = telemetryDefaults.SgCoreContainerImageURL
	}
	if spec.Ceilometer.CeilometerSpec.ProxyImage == "" {
		spec.Ceilometer.CeilometerSpec.ProxyImage = telemetryDefaults.ProxyContainerImageURL
	}
	if spec.Ceilometer.CeilometerSpec.KSMImage == "" {
		spec.Ceilometer.CeilometerSpec.KSMImage = telemetryDefaults.KsmContainerImageURL
	}
	if spec.Ceilometer.CeilometerSpec.MysqldExporterImage == "" {
		spec.Ceilometer.CeilometerSpec.MysqldExporterImage = telemetryDefaults.MysqldExporterContainerImageURL
	}
	if spec.Autoscaling.AutoscalingSpec.Aodh.APIImage == "" {
		spec.Autoscaling.AutoscalingSpec.Aodh.APIImage = telemetryDefaults.AodhAPIContainerImageURL
	}
	if spec.Autoscaling.AutoscalingSpec.Aodh.EvaluatorImage == "" {
		spec.Autoscaling.AutoscalingSpec.Aodh.EvaluatorImage = telemetryDefaults.AodhEvaluatorContainerImageURL
	}
	if spec.Autoscaling.AutoscalingSpec.Aodh.NotifierImage == "" {
		spec.Autoscaling.AutoscalingSpec.Aodh.NotifierImage = telemetryDefaults.AodhNotifierContainerImageURL
	}
	if spec.Autoscaling.AutoscalingSpec.Aodh.ListenerImage == "" {
		spec.Autoscaling.AutoscalingSpec.Aodh.ListenerImage = telemetryDefaults.AodhListenerContainerImageURL
	}
	if spec.CloudKitty.CloudKittyAPI.ContainerImage == "" {
		spec.CloudKitty.CloudKittyAPI.ContainerImage = telemetryDefaults.CloudKittyAPIContainerImageURL
	}
	if spec.CloudKitty.CloudKittyProc.ContainerImage == "" {
		spec.CloudKitty.CloudKittyProc.ContainerImage = telemetryDefaults.CloudKittyProcContainerImageURL
	}

	// Call nested Default() methods to set rabbitmq cluster defaults
	spec.Autoscaling.AutoscalingSpec.Default()
	spec.Autoscaling.Aodh.Default()
	spec.Ceilometer.CeilometerSpec.Default()
	spec.CloudKitty.CloudKittySpec.Default()
}

// Default - set defaults for this Telemetry spec core
// NOTE: only this version gets called by the Controlplane Webhook
func (spec *TelemetrySpecCore) Default() {
	spec.Autoscaling.Aodh.Default()
	spec.Ceilometer.Default()
	spec.CloudKitty.Default()
}

var _ webhook.Validator = &Telemetry{}

// ValidateCreate implements webhook.Validator so a webhook will be registered for the type
func (r *Telemetry) ValidateCreate() (admission.Warnings, error) {
	telemetrylog.Info("validate create", "name", r.Name)
	var allWarns []string
	var allErrs field.ErrorList
	basePath := field.NewPath("spec")

	warns, errs := r.Spec.ValidateCreate(basePath, r.Namespace)
	allWarns = append(allWarns, warns...)
	allErrs = append(allErrs, errs...)

	if len(allErrs) != 0 {
		return allWarns, apierrors.NewInvalid(
			schema.GroupKind{Group: "telemetry.openstack.org", Kind: "Telemetry"},
			r.Name, allErrs)
	}

	return allWarns, nil
}

func (r TelemetrySpec) ValidateCreate(basePath *field.Path, namespace string) ([]string, field.ErrorList) {
	var allErrs field.ErrorList
	var allWarns []string

	allErrs = append(allErrs, r.ValidateTelemetryTopology(basePath, namespace)...)
	if r.CloudKitty.Enabled != nil && *r.CloudKitty.Enabled {
		allErrs = append(allErrs, r.CloudKitty.CloudKittySpec.ValidateCreate(basePath.Child("cloudkitty"), namespace)...)
	}
	return allWarns, allErrs
}

func (r TelemetrySpecCore) ValidateCreate(basePath *field.Path, namespace string) ([]string, field.ErrorList) {
	var allErrs field.ErrorList
	var allWarns []string

	allErrs = append(allErrs, r.ValidateTelemetryTopology(basePath, namespace)...)
	if r.CloudKitty.Enabled != nil && *r.CloudKitty.Enabled {
		allErrs = append(allErrs, r.CloudKitty.CloudKittySpecCore.ValidateCreate(basePath.Child("cloudkitty"), namespace)...)
	}
	return allWarns, allErrs
}

// ValidateUpdate implements webhook.Validator so a webhook will be registered for the type
func (r *Telemetry) ValidateUpdate(old runtime.Object) (admission.Warnings, error) {
	telemetrylog.Info("validate update", "name", r.Name)
	var allWarns []string
	var allErrs field.ErrorList
	basePath := field.NewPath("spec")

	oldTelemetry, ok := old.(*Telemetry)
	if !ok || oldTelemetry == nil {
		return nil, apierrors.NewInternalError(fmt.Errorf("unable to convert existing object"))
	}

	warns, errs := r.Spec.ValidateUpdate(oldTelemetry.Spec, basePath, r.Namespace)
	allWarns = append(allWarns, warns...)
	allErrs = append(allErrs, errs...)

	if len(allErrs) != 0 {
		return allWarns, apierrors.NewInvalid(
			schema.GroupKind{Group: "telemetry.openstack.org", Kind: "Telemetry"},
			r.Name, allErrs)
	}
	return allWarns, nil
}

func (r TelemetrySpec) ValidateUpdate(old TelemetrySpec, basePath *field.Path, namespace string) ([]string, field.ErrorList) {
	var allErrs field.ErrorList
	var allWarns []string

	allErrs = append(allErrs, r.ValidateTelemetryTopology(basePath, namespace)...)

	if r.CloudKitty.Enabled != nil && *r.CloudKitty.Enabled {
		allErrs = append(allErrs, r.CloudKitty.CloudKittySpec.ValidateUpdate(old.CloudKitty.CloudKittySpec, basePath.Child("cloudkitty"), namespace)...)
	}
	return allWarns, allErrs
}

func (r TelemetrySpecCore) ValidateUpdate(old TelemetrySpecCore, basePath *field.Path, namespace string) ([]string, field.ErrorList) {
	var allErrs field.ErrorList
	var allWarns []string

	allErrs = append(allErrs, r.ValidateTelemetryTopology(basePath, namespace)...)
	if r.CloudKitty.Enabled != nil && *r.CloudKitty.Enabled {
		allErrs = append(allErrs, r.CloudKitty.CloudKittySpecCore.ValidateUpdate(old.CloudKitty.CloudKittySpecCore, basePath.Child("cloudkitty"), namespace)...)
	}
	return allWarns, allErrs
}

// ValidateDelete implements webhook.Validator so a webhook will be registered for the type
func (r *Telemetry) ValidateDelete() (admission.Warnings, error) {
	telemetrylog.Info("validate delete", "name", r.Name)

	// TODO(user): fill in your validation logic upon object deletion.
	return nil, nil
}

// ValidateTelemetryTopology - Returns an ErrorList if the Topology is referenced
// on a different namespace
func (spec *TelemetrySpecCore) ValidateTelemetryTopology(basePath *field.Path, namespace string) field.ErrorList {
	var allErrs field.ErrorList

	// When a TopologyRef CR is referenced, fail if a different Namespace is
	// referenced because is not supported
	allErrs = append(allErrs, topologyv1.ValidateTopologyRef(
		spec.TopologyRef, *basePath.Child("topologyRef"), namespace)...)

	// When a TopologyRef CR is referenced with an override to Aodh, fail
	// if a different Namespace is referenced because not supported
	aodhPath := basePath.Child("autoscaling").Child("aodh")
	allErrs = append(allErrs,
		spec.Autoscaling.Aodh.ValidateTopology(aodhPath, namespace)...)

	// When a TopologyRef CR is referenced with an override to Ceilometer,
	// fail if a different Namespace is referenced because not supported
	ceilPath := basePath.Child("ceilometer")
	allErrs = append(allErrs,
		spec.Ceilometer.ValidateTopology(ceilPath, namespace)...)

	// TODO: investigate whether a topology validation is needed for CloudKitty or MetricStorage

	return allErrs
}

// ValidateTelemetryTopology - Returns an ErrorList if the Topology is referenced
// on a different namespace
func (spec *TelemetrySpec) ValidateTelemetryTopology(basePath *field.Path, namespace string) field.ErrorList {
	var allErrs field.ErrorList

	// When a TopologyRef CR is referenced, fail if a different Namespace is
	// referenced because is not supported
	allErrs = append(allErrs, topologyv1.ValidateTopologyRef(
		spec.TopologyRef, *basePath.Child("topologyRef"), namespace)...)

	// When a TopologyRef CR is referenced with an override to Aodh, fail
	// if a different Namespace is referenced because not supported
	aodhPath := basePath.Child("autoscaling").Child("aodh")
	allErrs = append(allErrs,
		spec.Autoscaling.Aodh.ValidateTopology(aodhPath, namespace)...)

	// When a TopologyRef CR is referenced with an override to Ceilometer,
	// fail if a different Namespace is referenced because not supported
	ceilPath := basePath.Child("ceilometer")
	allErrs = append(allErrs,
		spec.Ceilometer.ValidateTopology(ceilPath, namespace)...)

	// TODO: investigate whether a topology validation is needed for CloudKitty or MetricStorage

	return allErrs
}
